9.1
 注意scanf()的返回值是直到第一个格式出错的输入变量前的所有正确输入个数，若第一个输入格式便出错则直接返回0.
9.2
 for(statement1;statement2;statement3)其中语句3一定是在执行完循环中内容之后再执行，语句3处写i++和++i效果一样，但++i比i++性能好
    设置断点，调试加单步执行可监控各个变量的值
    可用VS自带的分析功能生成代码运行报告，可查看运行时间，占用内存等
9.3
 C语言定义数组长度只能用常量来定义，不能int n=10; float array[n];因为此时n为变量，可用const使n变为常量（注意，在一些C标准下const int n=0;为常变量，即值固定的变量，其属性仍为变量，但在C++中带const就直接被判定为常量）
    对于数组array[10]而言, &array[i] 和 array+i 含义一样，都表示第n个元素的地址。但注意array不能进行自增操作，因为它是常指针，指向的地址是不能变的，array++是错误的，但array+i可以是因为array+i没有改变array指向的值。  
9.4
 {0}可将数组内容全置为0
    一维数组的每个元素都是一维数组，组成的便是二维数组。
    二维数组按元素初始化时是由先列递增而后再行递增的顺序存储每个数字的（类似于人正常读文章的顺序），与二维数组在地址空间中的存储方式相同。
9.5
 注意gets()接收换行符之前的内容作为输入数组，换行符不会被接收，因此可能产生换行符余留问题。
    puts()输出自动换行
9.6
 &为取地址操作。*为取内容操作，&(*ptr)还是指针ptr，*(&a)还是变量a
    指针变量可以和其他变量一起定义
    指针指向的地址大小即其类型数据所占的地址大小
    指针变量一定要初始化，如果是空的就赋值为NULL，否则会出现野指针问题。
    神出鬼没野指针，地老天荒死循环
    相同类型指针可以相互赋值。
    对于二维数组，先访问行再访问列，行指针的定义方式为
     int (*p)[4];//这定义了每行有4个元素（即数组有4列）的行指针
    此时p[i]表示的是第i行（默认为第一个元素）的地址，p[i]+j  表示的是i行j列的地址,与 p[i][j] 等价
    *(p[i]+j) 表示i行j列的元素，也可以写成 *(*(p+i)+j) 或者 (*(p+i))[j] 
    nt *p=*a//这定义了二维数组列指针，就相当于把二维数组按内存中存储顺序一字铺开，此时 p[i*n+j] 其中n为数组的列数，p[i*n+j] 表示的是i行j列的地址
9.7 
 strcat  string catenate
    typedef定义新的变量类型，可用于结构体类型的命名
    clock_t clock(void)可返回程序执行时间
	
    int *p[4];//此为指针数组
    字符指针数组存放的是指向字符串的指针，其指向的字符串长度不必预先定义，可以是不规则的长度
    定义为 char *str[100];//这是100个字符串指针，存的是100个字符串各自的首字符地址，分配的空间是  4x100+每个字符串实际的空间

    但字符二维数组定义时便确定了空间大小，比如char str[100][50];//定义了100个字符串的数组，其中字符串的最大长度为50，分配的空间就是50x100=500，相比之下字符指针数组更加灵活
//字符指针数组实战练习（待定）？？
    
二重指针：在二重指针中存放的是指向另一个变量的指针的地址，二重指针为指向指针的指针
定义为**p
注意，指针的地址是不能赋值给普通指针的，只有二重指针可以指向指针

注意，字符数组和字符串是有区别的
定义
char carray[]={'f','u','c','k'};
char cstring[]="fuck";等价于char cstring[5]="fuck";//cstring的长度至少得是5，因为有结束符
二者是不一样的，carray是数组，没有结束符号"\0"，但cstring有结束符，因此carray不能用%s来输出（除非在数组中人为添加结束符），但cstring可以用%s输出

char *p="hello";//这条语句在内存中以常量的方式存储了一个字符串hello，并把这个字符串的首地址赋值给了指针p,而且不能通过对p重新赋值来修改字符串的值，因为hello是常量不能被修改，但可以通过改变p的指向使其指向不同的内容

9.8 

在遇到问题时要善用单步调试查看变量来解决问题（重要）

计算字符串长度时不包括结束符 '\0'
 -> 为指向成员运算符，在通过结构指针访问结构体时用到这个符号 

注意！！
float c = 5 / 9;
printf("%f", c);
输出的是0.00000    因为5/9中的5和9默认都是按照int存储的，因此int/int会将int的结果赋给c
因此应该用
float c = 5.0 / 9.0;
printf("%f", c);
变为5.0和9.0之后这两个数类型为float，可得出正确结果

 >>可连续输入多个数据，输入方式为每行只输入一个数据，用回车结束，或者每行输入多个数据，用空格分割，回车结束输入

C++通过new 和delete管理动态内存
new执行失败返回NULL

使用方法为
int *p;
p=new int;//这样是为p分配一个int类型的空间
delete p;

p=new int(10);//这样是为p分配一个int类型的空间，并向其中存入10
delete p;

p=new int[10];//这样是为p分配10个int类型的内存，即一个10位的int数组，p指向首地址
delete []p;//其中的[]代表p指向的是数组空间

9.9



函数重载：同名的，参数个数或者类型不同的函数，系统会根据输入自动判断使用同名函数中的哪一个，出现混淆时会报错。
一般只把相同功能的函数进行重载，不同功能的函数不建议同名
注意：不能以形参名字或者返回值类型不同来区分函数，只能以形参个数或类型来区分


在声明函数的时候，默认形参值必须按照从右向左的方式声明，有默认形参值的参数一律放到右边，有默认值的形参右边不能再有无默认值的形参

在不同的作用域内声明同一函数时，允许声明不同的默认形参值，且声明的默认形参值仅在声明的作用域内有效




