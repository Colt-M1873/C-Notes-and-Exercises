9.1
 注意scanf()的返回值是直到第一个格式出错的输入变量前的所有正确输入个数，若第一个输入格式便出错则直接返回0.

9.2
 for(statement1;statement2;statement3)其中语句3一定是在执行完循环中内容之后再执行，语句3处写i++和++i效果一样，但++i比i++性能好
    设置断点，调试加单步执行可监控各个变量的值
    可用VS自带的分析功能生成代码运行报告，可查看运行时间，占用内存等

9.3
 C语言定义数组长度只能用常量来定义，不能int n=10; float array[n];因为此时n为变量，可用const使n变为常量（注意，在一些C标准下const int n=0;为常变量，即值固定的变量，其属性仍为变量，但在C++中带const就直接被判定为常量）
    对于数组array[10]而言, &array[i] 和 array+i 含义一样，都表示第n个元素的地址。但注意array不能进行自增操作，因为它是常指针，指向的地址是不能变的，array++是错误的，但array+i可以是因为array+i没有改变array指向的值。  

9.4
 {0}可将数组内容全置为0
    一维数组的每个元素都是一维数组，组成的便是二维数组。
    二维数组按元素初始化时是由先列递增而后再行递增的顺序存储每个数字的（类似于人正常读文章的顺序），与二维数组在地址空间中的存储方式相同。

9.5
 注意gets()接收换行符之前的内容作为输入数组，换行符不会被接收，因此可能产生换行符余留问题。
    puts()输出自动换行

9.6
 &为取地址操作。*为取内容操作，&(*ptr)还是指针ptr，*(&a)还是变量a
    指针变量可以和其他变量一起定义
    指针指向的地址大小即其类型数据所占的地址大小
    指针变量一定要初始化，如果是空的就赋值为NULL，否则会出现野指针问题。
    神出鬼没野指针，地老天荒死循环
    相同类型指针可以相互赋值。
    对于二维数组，先访问行再访问列，行指针的定义方式为
     int (*p)[4];//这定义了每行有4个元素（即数组有4列）的行指针
    此时p[i]表示的是第i行（默认为第一个元素）的地址，p[i]+j  表示的是i行j列的地址,与 p[i][j] 等价
    *(p[i]+j) 表示i行j列的元素，也可以写成 *(*(p+i)+j) 或者 (*(p+i))[j] 
    nt *p=*a//这定义了二维数组列指针，就相当于把二维数组按内存中存储顺序一字铺开，此时 p[i*n+j] 其中n为数组的列数，p[i*n+j] 表示的是i行j列的地址

在声明时可以直接赋值 int i=0; int *p=&i; 因为在声明时的*是说明符号，说明变量类型为指针
但在声明之后
int i=0, *p;   
p=&i;// 此时不带*号表示的是将&i即i的地址赋值给p指针，在不带*单独有p时表示在内存中属于该指针的的地址。可将指针p比作盒子，指针指向的地址&i比作盒子中的纸条，纸条上记着另一个盒子i的位置。这个操作就相当于将写着位置的纸条放入盒子中
*p=100;//此操作含义为将100赋值给i，此处的*是运算符，即访问这个指针值向的地址，带*号的*p表示这个指针指向的地址。即纸条的内容。这个操作相当于通过这个盒子中的纸条*p访问盒子i并将100存入其中。



9.7 
 strcat  string catenate
    typedef定义新的变量类型，可用于结构体类型的命名
    clock_t clock(void)可返回程序执行时间
	
    int *p[4];//此为指针数组
    字符指针数组存放的是指向字符串的指针，其指向的字符串长度不必预先定义，可以是不规则的长度
    定义为 char *str[100];//这是100个字符串指针，存的是100个字符串各自的首字符地址，分配的空间是  4x100+每个字符串实际的空间

    但字符二维数组定义时便确定了空间大小，比如char str[100][50];//定义了100个字符串的数组，其中字符串的最大长度为50，分配的空间就是50x100=500，相比之下字符指针数组更加灵活
//字符指针数组实战练习（待定）？？
    
二重指针：在二重指针中存放的是指向另一个变量的指针的地址，二重指针为指向指针的指针
定义为**p
注意，指针的地址是不能赋值给普通指针的，只有二重指针可以指向指针

注意，字符数组和字符串是有区别的
定义
char carray[]={'f','u','c','k'};
char cstring[]="fuck";等价于char cstring[5]="fuck";//cstring的长度至少得是5，因为有结束符
二者是不一样的，carray是数组，没有结束符号"\0"，但cstring有结束符，因此carray不能用%s来输出（除非在数组中人为添加结束符），但cstring可以用%s输出

char *p="hello";//这条语句在内存中以常量的方式存储了一个字符串hello，并把这个字符串的首地址赋值给了指针p,而且不能通过对p重新赋值来修改字符串的值，因为hello是常量不能被修改，但可以通过改变p的指向使其指向不同的内容

9.8 

在遇到问题时要善用单步调试查看变量来解决问题（重要）

计算字符串长度时不包括结束符 '\0'
 -> 为指向成员运算符，在通过结构指针访问结构体时用到这个符号 

注意！！
float c = 5 / 9;
printf("%f", c);
输出的是0.00000    因为5/9中的5和9默认都是按照int存储的，因此int/int会将int的结果赋给c
因此应该用
float c = 5.0 / 9.0;
printf("%f", c);
变为5.0和9.0之后这两个数类型为float，可得出正确结果

 >>可连续输入多个数据，输入方式为每行只输入一个数据，用回车结束，或者每行输入多个数据，用空格分割，回车结束输入

C++通过new 和delete管理动态内存
new执行失败返回NULL

使用方法为
int *p;
p=new int;//这样是为p分配一个int类型的空间
delete p;

p=new int(10);//这样是为p分配一个int类型的空间，并向其中存入10
delete p;

p=new int[10];//这样是为p分配10个int类型的内存，即一个10位的int数组，p指向首地址
delete []p;//其中的[]代表p指向的是数组空间

9.9

函数重载：同名的，参数个数或者类型不同的函数，系统会根据输入自动判断使用同名函数中的哪一个，出现混淆时会报错。
一般只把相同功能的函数进行重载，不同功能的函数不建议同名
注意：不能以形参名字或者返回值类型不同来区分函数，只能以形参个数或类型来区分


在声明函数的时候，默认形参值必须按照从右向左的方式声明，有默认形参值的参数一律放到右边，有默认值的形参右边不能再有无默认值的形参

在不同的作用域内声明同一函数时，允许声明不同的默认形参值，且声明的默认形参值仅在声明的作用域内有效


9.10
宏定义替换中，内容带有++时容易出错
如 #define abs(a) ( (a) < 0 ? -(a) : (a) )
int m=-2;  ret=abs(++m);
正确输出应为1
但最终输出ret的结果是0
因为用++m替换得到的表达式为
ret=( (++m) < 0 ? -(++m) : (++m) );
其中++m执行了两次

宏定义替换不能带分号
宏定义的好处是不需要调用函数，比调用函数占用的系统资源更少，且宏定义的参数适用于大多数类型的数据
缺点是没有类型检查，副作用可能难以预料

内联函数：
在定义前加上 inline 即表示该函数为内联函数
程序在执行到内联函数的时候先检验参数类型，而后直接用函数体对这段代码进行替换

一般只把需要频繁调用的，长度较短只有几条语句的定义为内联函数

内联函数中不允许含有循环语句和switch语句，否则自动按照普通函数来处理


C语言不认可const为常量，认为其是值不能改变的变量，因此C语言中const定义的内容不能作为数组长度等
但C++中可以将const作为常量，声明时必须赋初值

独立引用
int m;
int &pm=m;
此时pm与m指向的是同一个地址，pm是m的引用，相当于pm是m的别名

const float &pm=1.0;//定义r2为实数常量，值为1.0

定义常引用
int x=1;
const int &rx=x;
此时rx只能被读出但不能被修改


9.11


定义指针调用函数
int func ( int *p){}
调用该函数
func(&a);
对于形参为指针的，在调用时应当向其中传入地址

在调用函数时，仅仅把实参的值拷贝一份副本传给形参而后执行函数，不会改变实参的值

要改变实参值，在C语言中可用指针调用，需要特地为指针分配空间

在C++中还可用引用调用，将函数的形参以引用形式声明，在调用时形参作为实参的一个引用或者说别名，对形参的操作就是对实参本身的操作
引用调用不需要额外为形参的指针开辟地址，因此更节省空间。不需要通过指针间接访问，而是直接访问实参的内容，因此更节省时间。
引用调用举例：
int func(int &m){}//参数值为引用
int &func(int m){}//返回值为引用
当返回值为引用时可以出现在等号左侧，相当于把等号右侧内容赋给返回值的地址

面向过程：首先考虑步骤
面向对象：首先考虑数据，要获取那些数据，要对数据进行那些处理
将多个数据组成的对象作为基本数据单元
指定基本类型：1 定义内存数量
2 定义如何解释内存中的位
3 定义可对对象（数据）进行怎样的操作或称方法


9.12
函数的返回值不能是局部变量的地址

9.13
执行函数时占用栈中的空间，一旦函数运行完毕返回，则栈中空间释放，这就是函数中对形参进行操作不影响实参的原因
输出参数：将函数形参定义为传递地址则可实现用参数输出，只需在执行函数后访问传入的地址即可实现输出功能。







































